import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db';
import { brainDumps, aiProcessingResults, autoGeneratedContent } from '../../../../../database/schemas/brain-dump';
import { quests, questObjectives } from '../../../../../database/schemas/quests';
import { eq } from 'drizzle-orm';

interface GenerateQuestRequest {
  brainDumpId: string;
  questName?: string;
  questDescription?: string;
  objectives?: string[];
  questType?: 'main' | 'side' | 'daily' | 'weekly' | 'epic';
  difficulty?: 'trivial' | 'easy' | 'normal' | 'hard' | 'legendary';
}

export async function POST(request: NextRequest) {
  try {
    const body: GenerateQuestRequest = await request.json();
    const { brainDumpId, questName, questDescription, objectives, questType = 'side', difficulty = 'normal' } = body;

    if (!brainDumpId) {
      return NextResponse.json(
        { error: 'Brain dump ID is required' },
        { status: 400 }
      );
    }

    // Get the brain dump and its processing results
    const [brainDump] = await db.select()
      .from(brainDumps)
      .where(eq(brainDumps.id, brainDumpId))
      .limit(1);

    if (!brainDump) {
      return NextResponse.json(
        { error: 'Brain dump not found' },
        { status: 404 }
      );
    }

    const processingResults = await db.select()
      .from(aiProcessingResults)
      .where(eq(aiProcessingResults.brainDumpId, brainDumpId))
      .limit(1);

    // Generate quest from AI processing results or brain dump content
    let generatedQuestName = questName;
    let generatedQuestDescription = questDescription;
    let generatedObjectives = objectives || [];
    let calculatedXpReward = 50; // base XP

    if (processingResults.length > 0) {
      const aiResult = processingResults[0];
      
      if (!generatedQuestName) {
        // Generate quest name from categories and urgency
        const extractedEntities = aiResult.extractedEntities as Record<string, unknown>;
        const categories = Array.isArray(extractedEntities?.categories) 
          ? extractedEntities.categories as string[]
          : [];
        const primaryCategory = categories[0] || 'general';
        const urgencyPrefix = aiResult.detectedUrgency === 'now' ? 'Urgent: ' : '';
        generatedQuestName = `${urgencyPrefix}${primaryCategory.charAt(0).toUpperCase() + primaryCategory.slice(1)} Quest`;
      }

      if (!generatedQuestDescription) {
        generatedQuestDescription = aiResult.aiInterpretation || `Complete tasks related to: ${brainDump.rawText.substring(0, 100)}...`;
      }

      // Calculate XP based on priority and urgency
      if (aiResult.detectedUrgency === 'now') calculatedXpReward += 30;
      else if (aiResult.detectedUrgency === 'today') calculatedXpReward += 20;
      else if (aiResult.detectedUrgency === 'this_week') calculatedXpReward += 10;

      // Extract tasks as objectives if not provided
      if (generatedObjectives.length === 0) {
        const extractedEntities = aiResult.extractedEntities as Record<string, unknown>;
        if (Array.isArray(extractedEntities?.extractedTasks)) {
          generatedObjectives = (extractedEntities.extractedTasks as Array<{ text: string }>).map(task => task.text);
        } else {
          // Fallback: create one objective from the brain dump
          generatedObjectives = [brainDump.rawText.substring(0, 200)];
        }
      }
    } else {
      // Fallback for unprocessed brain dumps
      if (!generatedQuestName) {
        generatedQuestName = 'Complete Brain Dump Task';
      }
      if (!generatedQuestDescription) {
        generatedQuestDescription = brainDump.rawText;
      }
      if (generatedObjectives.length === 0) {
        generatedObjectives = [brainDump.rawText.substring(0, 200)];
      }
    }

    // Create the quest
    const [quest] = await db.insert(quests).values({
      questName: generatedQuestName,
      questDescription: generatedQuestDescription,
      questType,
      difficulty,
      xpReward: calculatedXpReward,
    }).returning();

    // Create objectives
    const createdObjectives = [];
    for (let i = 0; i < generatedObjectives.length; i++) {
      const [objective] = await db.insert(questObjectives).values({
        questId: quest.id,
        objectiveText: generatedObjectives[i],
        objectiveOrder: i + 1,
        xpReward: Math.floor(calculatedXpReward / generatedObjectives.length),
      }).returning();
      createdObjectives.push(objective);
    }

    // Track as auto-generated content
    await db.insert(autoGeneratedContent).values({
      sourceDumpId: brainDumpId,
      contentType: 'quest',
      contentId: quest.id,
      autoGenerated: true,
    });

    return NextResponse.json({
      success: true,
      data: {
        quest,
        objectives: createdObjectives,
        generatedFrom: brainDump.id,
        confidenceScore: processingResults[0]?.extractedEntities ? 0.8 : 0.6
      }
    });

  } catch (error) {
    console.error('Error generating quest:', error);
    return NextResponse.json(
      { error: 'Failed to generate quest' },
      { status: 500 }
    );
  }
}